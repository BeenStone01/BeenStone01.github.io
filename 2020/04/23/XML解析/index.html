<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		XML解析 | 
	 
	Been&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="my markdown blog" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Been's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/BeenStone01" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2020/04/23/C++%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B/">
										C++代码样例
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/19/GPIB/">
										GPIB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/Laravel/">
										Laravel
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/Linux%E5%9C%A8%E7%BA%BF/">
										Linux在线
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/29/MFC/">
										MFC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/29/MFC%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
										MFC多线程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/MFC%E8%87%AA%E7%BB%98%E6%8C%89%E9%92%AE/">
										MFC自绘按钮
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/MFC%E8%87%AA%E7%BB%98%E6%A6%82%E8%BF%B0/">
										MFC自绘概述
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/SSDP%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/">
										SSDP开发说明
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/STL_vector/">
										STL_vector
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/STL/">
										STL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/WinHttp%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">
										WinHttp使用详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/WinInet%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">
										WinInet使用详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/Wininte%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90/">
										Wininte样例解析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/26/XML%E4%B9%8BIXMLHTTPReuest/">
										XML之IXMLHTTPReuest
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/XML%E6%93%8D%E4%BD%9C%E4%B9%8BCMarkUp/">
										XML操作之CMarkUp
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2020/04/23/XML%E8%A7%A3%E6%9E%90/">
										XML解析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/c++11/">
										c++11
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/06/c++%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										c++小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/26/c-%E6%9C%AA%E5%BD%92%E7%B1%BB%E4%BB%A3%E7%A0%81/">
										c-未归类代码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/hexo/">
										hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/socket/">
										socket
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/thread-2/">
										thread-2
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/thread/">
										thread
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/vue%E7%AC%94%E8%AE%B0/">
										vue笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/webpack%E4%BD%BF%E7%94%A8/">
										webpack使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/30/%E4%B8%B2%E5%8F%A3com%E7%BC%96%E7%A8%8B/">
										串口com编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/03/%E5%88%B7%E9%A2%98%E7%BA%AA%E5%BD%95/">
										刷题纪录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/">
										字符类型
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">
										小程序开发笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">
										常用工具命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/">
										文件读写
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/">
										编码格式转换
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	XML解析
</h1>
<div class="article-meta">
	
	<span>Been Stone</span>
	<span>2020-04-23 17:08:18</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>XML在Win32程序方面应该没有在Web方面应用得多，很多Win32程序也只是用XML来存存配置信息而已，而且没有足够的好处的话还不如用ini。VC++里操作XML有两个库可以用：MSXML和XmlLite。MSXML又细分了两种接口：DOM和SAX2。XP没自带有XmlLite，只自带有2.x、3.x版的MSXML，不支持SAX2（需要MSXML 4.0以上），所以优先使用DOM。<br>DOM是以COM形式提供的，VC++里调用DOM可以分3种方法：</p>
<ol>
<li>MFC里用CComPtr调用</li>
<li>SDK里直接调用DOM接口</li>
<li>SDK里用智能指针调用      </li>
</ol>
<p>这3种方法本质上是一样的，区别只不过在于需要编码的多少而已，用CComPtr可以极大的简化代码，下面是几个例子。</p>
<p>XML中的常见数据类型：<code>Element, Attribute, Comment, Text</code>     </p>
<p>Element,指型如<Name>Tom<Name>的子节点。它可以包括<code>Element, Text, Comment, ProcessingInstruction, CDATA, and EntityReference</code>.<br>Comment,指型如<code>&lt;!-- Name --&gt;</code>的节点</p>
<h2 id="MFC版本"><a href="#MFC版本" class="headerlink" title="MFC版本"></a>MFC版本</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>需要在<code>CWinApp::InitInstance()</code>中调用<code>CoInitialize(NULL)</code>是初始化COM, 在CWinApp::ExitInstance()中调用CoUninitialize()释放COM就行了。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root&gt;
    &lt;node1&gt;text1&lt;/node1&gt;
    &lt;node2&gt;
        &lt;childnode1 attrib1=&quot;value1&quot; attrib2=&quot;value2&quot;/&gt;
        &lt;childnode2 attrib1=&quot;value1&quot; attrib2=&quot;value2&quot;&gt;childtext1&lt;/childnode2&gt;
        &lt;childnode2&gt;childtext&lt;/childnode2&gt;
    &lt;/node2&gt;
&lt;/root&gt;</code></pre>
<h3 id="读取信息"><a href="#读取信息" class="headerlink" title="读取信息"></a>读取信息</h3><pre><code class="cpp">CFile file;
cFile.Open(_T(&quot;./device.xml&quot;), CFile::modeRead | CFile::shareDenyNone);
CFileStatus stat;
cFile.GetStatus(stat);
char* pText = new char[stat.m_size + 1];
int nRet = cFile.Read(pText, (UINT)stat.m_size);
pText[nRet] = 0;
CString szContent = GetStringWFromUtf8(pText, stat.m_size+1);   //utf8 转换为 宽字节

CComPtr&lt;IXMLDOMDocument&gt; spDoc;                            //DOM
spDoc.CoCreateInstance(CLSID_DOMDocument);
VARIANT_BOOL vb;
BSTR bsTRContent = szContent.AllocSysString();          //CString → BSTR
spDoc-&gt;loadXML(bsTRContent, &amp;vb);                        //加载XML文件
//spDoc-&gt;load(CComVariant(OLESTR(&quot;device.xml&quot;)), &amp;vb);
CComPtr&lt;IXMLDOMElement&gt; spRootEle;
spDoc-&gt;get_documentElement(&amp;spRootEle);                //根节点
CComPtr&lt;IXMLDOMNodeList&gt; spNodeList;
spRootEle-&gt;get_childNodes(&amp;spNodeList);                //子节点列表
long nLen;
spNodeList-&gt;get_length(&amp;nLen);
for(long i = 0; i != nLen; ++i)
{
    CComPtr&lt;IXMLDOMNode&gt; spNode;
    spNodeList-&gt;get_item(i, &amp;spNode);       //获取列表中的节点
    ProcessNode(spNode);                    //节点处理函数
}

void ProcessNode(CComPtr&lt;IXMLDOMNode&gt;&amp; spNode)
{
    CComBSTR bsNodeName;
    spNode-&gt;get_nodeName(&amp;bsNodeName);      //节点名
    AfxMessageBox(COLE2CT(bsNodeName));
    CComVariant varVal;
    spNode-&gt;get_nodeValue(&amp;varVal);         //节点值
    AfxMessageBox(COLE2CT(varVal.bstrVal));

    DOMNodeType eNodeType;
    spNode-&gt;get_nodeType(&amp;eNodeType);
    if(eNodeType == NODE_ELEMENT)      //只有NODE_ELEMENT类型才能包含属性和子节点
    {
        //递归遍历节点属性
        CComPtr&lt;IXMLDOMNameNodeMap&gt; spNameNodeMap;
        spNode-&gt;get_attributes(&amp;spNameNodeMap);
        long nLen;
        spNameNodeMap-&gt;get_length(&amp;nLen);
        for(long i = 0; i != nLen; ++i)
        {
            CComPtr&lt;IXMLDOMNode&gt; spNodeAttrib;      //注意属性也是一个IXMLDOMNode
            spNameNodeMap-&gt;get_item(i, &amp;spNodeAttrib);
            ProcessNode(spNodeAttrib);
        }

        //递归遍历子节点
        CComPtr&lt;IXMLDOMNodeList&gt; spNodeList;
        spNode-&gt;get_childNodes(&amp;spNodeList);        //获取子节点
        spNodeList-&gt;get_length(&amp;nLen);
        for(long i = 0; i != nLen; ++i)
        {
            CComPtr&lt;IXMLDOMNode&gt; spChildNode;
            spNodeList-&gt;get_item(i, &amp;spChildNode);
            ProcessNode(spChildNode);
        }
    }
}
</code></pre>
<p>对于<code>&lt;tag&gt;text&lt;/tag&gt;</code>这样的节点，<code>get_nodeValue</code>会得到空，要得到”text”的话可以遍历子节点（只有一个子节点，它的<code>nodeName</code>为<code>&quot;#text&quot;</code>，<code>nodeType</code>为<code>NODE_TEXT</code>，<code>nodeValue</code>就是<code>&quot;text&quot;</code>）；也可以用<code>get_text</code>直接得到<code>&quot;text&quot;</code>，但是对于这样的节点<code>&lt;tag&gt;text&lt;childtag&gt;childtext&lt;/childtag&gt;&lt;/tag&gt;</code>，<code>get_text</code>会同时得到<code>&quot;text&quot;</code>和<code>&quot;childtext&quot;</code>，不过这样的节点应该是不允许的。     </p>
<p>DOM里使用的字符串(BSTR)都是<code>OLESTR</code>类型，默认情况下<code>OLESTR</code>是Unicode字符，MFC里可以用<code>COLE2CT</code>把<code>LPCOLESTR</code>转换为<code>LPCTSTR</code>。    </p>
<p>对于自己定义的XML，大多数时候不需要遍历，可以通过调用selectNodes、selectSingleNode指定XPath直接读取某个节点或属性：   </p>
<h3 id="查询节点方法"><a href="#查询节点方法" class="headerlink" title="查询节点方法"></a>查询节点方法</h3><pre><code class="cpp">CComPtr&lt;IXMLDOMNode&gt; spNode;
CComPtr&lt;IXMLDOMNodeList&gt; spNodeList;
spRootEle-&gt;get_childNodes(&amp;spNodeList);                                             //获取所有子节点


//selectSingleNode()方法查询到一个或多个节点，返回第一个节点。
spRootEle-&gt;selectSingleNode(OLESTR(&quot;/root/node2/childnode1/@attrib1&quot;), &amp;spNode);      //得到childnode1的attrib1属性
if(NULL == spNode.p)
    return;

spNode = NULL;
spRootEle-&gt;selectSingleNode(OLESTR(&quot;/root/node2/childnode2[text()=&#39;childtext&#39;]&quot;), &amp;spNode);

spServiceNode-&gt;selectSingleNode(OLESTR(&quot;./SCPDURL&quot;), &amp;sURLNode);                    //相对路径
spRootEle-&gt;selectNodes(OLESTR(&quot;/root/node2/*&quot;), &amp;spNodeList);                       //得到node2下的所有子节点
</code></pre>
<h3 id="写入信息"><a href="#写入信息" class="headerlink" title="写入信息"></a>写入信息</h3><pre><code class="cpp">CComPtr&lt;IXMLDOMNode&gt; spNode;
spRootEle-&gt;selectSingle(OLESTR(&quot;/root/node1&quot;), &amp;spNode);
spNode-&gt;put_text(OLESTR(&quot;newText&quot;));                            //写入text
spRootEle-&gt;selectSingle(COESTR(&quot;/root/node2/childnode1/@attrib1&quot;), &amp;spNode);
spNode-&gt;put_nodeValue(CComVariant(OLESTR(&quot;newValue&quot;)));        //写入value
CComPtr&lt;IXMLDOMNode&gt; spNewNode;
spDoc-&gt;CreateNode(CComVariant(NODE_ELEMENT), OLESTR(&quot;childnode3&quot;), OLESTR(&quot;&quot;), &amp;spNewNode);       //创建新节点
spRootEle-&gt;SelectSingleNode(OLESTR(&quot;/root/node2&quot;), &amp;spNode);
spNode-&gt;appendChild(spNewNode, &amp;spNewNode);         //将新节点加为node2的子节点
spNewNode-&gt;put_text(OLESTR(&quot;childtext2&quot;));          //写入新节点text
CComQIptr&lt;IXMLDOMElement&gt; spEle = spNewNode;        //注意这里使用CComQIPtr
spEle-&gt;SetAttribute(OLESTR(&quot;attrib1&quot;), CComVariant(OLESTR(&quot;value1&quot;)));  //给新节点添加属性
spDoc-&gt;save(CComVariant(OLESTR(&quot;test.xml&quot;)));</code></pre>
<h3 id="xpath查询某节点用法"><a href="#xpath查询某节点用法" class="headerlink" title="xpath查询某节点用法"></a>xpath查询某节点用法</h3><p>以下方法出自其他地方，仅作参考, 参例详见附件《XML样例.xml》 </p>
<pre><code class="cpp">//查询绝对路径
objNodeList = objDoc.SelectNodes(&quot;Company/Department/Employees/Employee&quot;);
objNodeList = objNode.SelectNodes(&quot;/Company/Department/Employees/Employee&quot;);

//查询相对路径
objNode = objDoc.SelectSingleNode(&quot;Company/Department&quot;);
objNode = objNode.SelectNode(&quot;Employees/Employee&quot;);
objNOdeList = objNode.SelectNodes(&quot;../Department&quot;); 

//由于不知道中间层次的元素名，可使用//符号来越过中间的节点，查询其子，孙或多层次下的其他所有元素。例如
objNodeList = objDoc.SelectNodes(&quot;Company//Employee&quot;);

//查询Text类节点
objNode = objDoc.SelectSingleNode(&quot;Company/Department/Depart_Name/text()&quot;);

//查询特定条件的节点
objNode = objDoc.SelectSingleNode(&quot;Company/Department/Employees/Employee[@id=&#39;10102&#39;]&quot;);
objNode = objDoc.SelectSingleNode(&quot;Company/Department/Employees/Employee/Name[text()=&#39;Zhang Qi&#39;]&quot;);
objNode = objDoc.SelectSingleNode(&quot;Company/Department[Employees/Employee/&amp;id=&#39;22345&#39;]/Department_Name&quot;);

//查询多重模式的节点（使用|符号）
objNodeList = objDoc.SelectNodes(&quot;Company/Department/Department_Name | Company/Department/Manager&quot;);

//查询任意节点
objNodeList = objDoc.SelectNodes(&quot;Company/✳/Managet&quot;);
objNodeList = objNode.ChildNodes;
</code></pre>
<h2 id="SDK版本"><a href="#SDK版本" class="headerlink" title="SDK版本"></a>SDK版本</h2><h3 id="官方开发文档"><a href="#官方开发文档" class="headerlink" title="官方开发文档"></a>官方开发文档</h3><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753804%28v%3dvs.85%29" target="_blank" rel="noopener">Building MSXML Applications</a><br>MSXML开发环境设置存在两种方法：</p>
<ol>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms758753%28v%3dvs.85%29" target="_blank" rel="noopener">Include Headers and Libraries Manually</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753736%28v%3dvs.85%29" target="_blank" rel="noopener">Set Up My Visual C++ Project</a>    </li>
</ol>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;atlbase.h&gt;
#include &lt;comdef.h&gt;
#include &lt;MsXml6.h&gt;
#pragma comment(lib,&quot;msxml6.lib&quot;)
//#include &lt;comutil.h&gt;
//#pragma comment(lib, &quot;comsuppw.lib&quot;)

using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{
    CoInitialize(NULL);
    printf(&quot;start using MSXML6\n&quot;);

    // Add your code here.

    CoUninitialize();
    return 0;
}</code></pre>
<ol start="2">
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms765540(v=vs.85)" target="_blank" rel="noopener">Get Ready to Work with MSXML (C-C++)</a></li>
</ol>
<pre><code class="cpp">#import &lt;msxml3.dll&gt; raw_interfaces_only

using namespace MSXML2;</code></pre>
<p><font color=blue>Microsoft recommends that you include headers and libraries manually, rather than using the #import directive.</font> </p>
<h3 id="xml获取"><a href="#xml获取" class="headerlink" title="xml获取"></a>xml获取</h3><h4 id="1-lt-msxml6-h-gt"><a href="#1-lt-msxml6-h-gt" class="headerlink" title="1. &lt;msxml6.h&gt;"></a>1. &lt;msxml6.h&gt;</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;atlbase.h&gt;
#include &lt;comdef.h&gt;
#include &lt;msxml6.h&gt;
#pragma comment(lib,&quot;msxml6.lib&quot;)

using namespace std;

int main()
{
    CoInitialize(NULL);
    HRESULT hr;
    CComPtr&lt;IXMLHTTPRequest&gt; request;

    hr = request.CoCreateInstance(CLSID_XMLHTTP60);     //CLSID_XMLHTTPRequest亦可
    hr = request-&gt;open(
        _bstr_t(&quot;GET&quot;),
        _bstr_t(&quot;http://192.168.1.77:49152/TxMediaRenderer_desc.xml&quot;),
        _variant_t(VARIANT_FALSE),
        _variant_t(),
        _variant_t());
    hr = request-&gt;send(_variant_t());
    long status;
    hr = request-&gt;get_status(&amp;status);

    BSTR bstrText;
    request-&gt;get_responseText(&amp;bstrText);

    cout &lt;&lt; _com_util::ConvertBSTRToString(bstrText) &lt;&lt; endl;

    SysFreeString(bstrText);
    request.Detach();
    CoUninitialize();
    system(&quot;pause&quot;);
    return 0;
}

// load image data (if url points to an image)
//VARIANT responseVariant;
//hr = request-&gt;get_responseStream(&amp;responseVariant);
//IStream* stream = (IStream*)responseVariant.punkVal;
//CImage image = new CImage();
//image-&gt;Load(stream);
//stream-&gt;Release();</code></pre>
<h4 id="2-msxml6-dll"><a href="#2-msxml6-dll" class="headerlink" title="2. msxml6.dll"></a>2. msxml6.dll</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;atlbase.h&gt;
#import &lt;msxml6.dll&gt;

using namespace MSXML2;

void GetXml()
{
    IXMLHTTPRequestPtr request = NULL;
    BSTR bstrText = NULL;
    HRESULT hr;
    hr = request.CreateInstance(&quot;MSXML2.XMLHTTP.6.0&quot;);
    if (FAILED(hr))
    {
        printf(&quot;IXMLHTTTPRequest: Failed to CreateInstance()!&quot;);
        return;
    }
    hr = request-&gt;open(&quot;GET&quot;, &quot;http://192.168.1.7:49152/TxMediaRenderer_desc.xml&quot;, false);
    if (FAILED(hr))
    {
        printf(&quot;IXMLHTTTPRequest: Failed to open()!&quot;);
        return;
    }
    hr = request-&gt;send();
    if (FAILED(hr))
    {
        printf(&quot;IXMLHTTTPRequest: Failed to send()!&quot;);
        return;
    }
    bstrText = request-&gt;responseText;
    if (bstrText)
    {
        _bstr_t b = bstrText;
        char* pstr = b;
        printf(&quot;%s&quot;, pstr);
        SysFreeString(bstrText);
        bstrText = NULL;
    }
    request.Release();
}

int main()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf(&quot;IXMLHTTTPRequest: Failed to send()!&quot;);
        return -1;
    }

    GetXml();

    CoUninitialize();
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<hr>
<h3 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h3><h5 id="MSDN：IXMLDOMDocumentPtr"><a href="#MSDN：IXMLDOMDocumentPtr" class="headerlink" title="MSDN：IXMLDOMDocumentPtr"></a><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms762752(v=vs.85)" target="_blank" rel="noopener">MSDN：IXMLDOMDocumentPtr</a></h5><pre><code class="cpp">#include &quot;msxml6.h&quot;  

inline void TESTHR( HRESULT _hr )   
   { if FAILED(_hr) throw(_hr); }  

void XMLDOMDocumentTypeSample()  
{  
   try  
   {  
      IXMLDOMDocumentPtr docPtr;  

      //init  
      TESTHR(CoInitialize(NULL));   
      TESTHR(docPtr.CreateInstance(_T(&quot;Msxml2.DOMDocument.3.0&quot;)));  

      // Load a document.  
      _variant_t varXml(_T(&quot;book1.xml&quot;));  
      _variant_t varOut((bool)TRUE);  
      varOut = docPtr-&gt;load(varXml);  
      if ((bool)varOut == FALSE)  
      {// Show error description - IXMLDOMParseError sample.  
         IXMLDOMParseErrorPtr errPtr = docPtr-&gt;GetparseError();  
      // Print error details.  
      }  
      else  
      {  
         IXMLDOMDocumentTypePtr docTypPtr = docPtr-&gt;doctype;  
         if (docTypPtr)  
         {  
            _bstr_t bstrTyp(docTypPtr-&gt;name);  
            _tprintf(_T(&quot;Document type name = %s\n&quot;), (TCHAR*)bstrTyp);  
         }  
            }  
   }  
   catch (_com_error &amp;e)  
   {  
      _tprintf(_T(&quot;Error:\n&quot;));  
      _tprintf(_T(&quot;Code = %08lx\n&quot;), e.Error());  
      _tprintf(_T(&quot;Code meaning = %s\n&quot;), (TCHAR*) e.ErrorMessage());  
      _tprintf(_T(&quot;Source = %s\n&quot;), (TCHAR*) e.Source());  
      _tprintf(_T(&quot;Error Description = %s\n&quot;), (TCHAR*) e.Description());  
   }  
      catch(...)  
   {  
      _tprintf(_T(&quot;Unknown error!&quot;));  
   }  
   CoUninitialize();  
}  </code></pre>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms756987(v=vs.85)" target="_blank" rel="noopener">IXMLDOMDocument-DOMDocument</a>    </p>
<pre><code class="cpp">HRESULT hr;  
IXMLDOMDocument * pXMLDoc;  
IXMLDOMNode * pXDN;  
//...  
hr = CoInitialize(NULL);   
// Check the return value, hr...  
hr = CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER,   
       IID_IXMLDOMDocument, (void**)&amp;pXMLDoc);  
// Check the return value, hr...  
hr = pXMLDoc-&gt;QueryInterface(IID_IXMLDOMNode, (void **)&amp;pXDN);  
// Check the return value.  </code></pre>
<p><font color=purple>In addition to the DOM interfaces, DOMDocument implements a number of standard COM interfaces. You can call the QueryInterface method on DOMDocument to get the following interfaces.</font><br>待续</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><h3 id="其他来源"><a href="#其他来源" class="headerlink" title="其他来源"></a>其他来源</h3><ol>
<li><a href="https://www.cnblogs.com/lingyun1120/archive/2011/11/02/2232709.html" target="_blank" rel="noopener">VC++中操作XML(MFC, SDK)</a>    </li>
<li><a href="https://www.cnblogs.com/love201314/p/5589784.html" target="_blank" rel="noopener">Xml中SelectSingleNode方法，xpath查找某节点用法</a></li>
<li><a href="https://www.xuebuyuan.com/303221.html" target="_blank" rel="noopener">XMLDOM的CComPtr的例程</a>       </li>
<li><a href="https://www.cnblogs.com/jetyi/articles/2740802.html" target="_blank" rel="noopener">HttpOpenRequest和HttpSendRequest使用及HTTP头设置</a><h3 id="MSDN"><a href="#MSDN" class="headerlink" title="MSDN"></a>MSDN</h3></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms759148%28v%3dvs.85%29" target="_blank" rel="noopener">IXMLHTTPRequest</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms757849(v=vs.85)" target="_blank" rel="noopener">open Method (IXMLHTTPRequest)</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms757055%28v%3dvs.85%29" target="_blank" rel="noopener">responseXML Property (ServerXMLHTTP-IServerXMLHTTPRequest)</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753682%28v%3dvs.85%29" target="_blank" rel="noopener">responseBody Property (ServerXMLHTTPRequest-IServerXMLHTTPRequest)</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms763684%28v%3dvs.85%29" target="_blank" rel="noopener">responseText Property (ServerXMLHTTP-IServerXMLHTTPRequest)</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms759211%28v%3dvs.85%29" target="_blank" rel="noopener">responseStream Property (ServerXMLHTTP-IServerXMLHTTPRequest)</a></li>
</ol>
<h2 id="微软示例代码："><a href="#微软示例代码：" class="headerlink" title="微软示例代码："></a>微软示例代码：</h2><h3 id="xml获取-1"><a href="#xml获取-1" class="headerlink" title="xml获取"></a>xml获取</h3><h4 id="1-IXMLHTTPRequest"><a href="#1-IXMLHTTPRequest" class="headerlink" title="1. IXMLHTTPRequest"></a>1. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms759148%28v%3dvs.85%29" target="_blank" rel="noopener">IXMLHTTPRequest</a></h4><pre><code class="cpp">#import &quot;msxml6.dll&quot;  
using namespace MSXML2;  

void XMLHttpRequestSample()  
{  
   IXMLHTTPRequestPtr pIXMLHTTPRequest = NULL;  
   BSTR bstrString = NULL;  
   HRESULT hr;  

   try {  
      hr=pIXMLHTTPRequest.CreateInstance(&quot;Msxml2.XMLHTTP.6.0&quot;);  
      SUCCEEDED(hr) ? 0 : throw hr;  

      hr=pIXMLHTTPRequest-&gt;open(&quot;GET&quot;, &quot;http://localhost/books.xml &quot;, false);  
      SUCCEEDED(hr) ? 0 : throw hr;  

      hr=pIXMLHTTPRequest-&gt;send();  
      SUCCEEDED(hr) ? 0 : throw hr;  

      bstrString=pIXMLHTTPRequest-&gt;responseText;  

      MessageBox(NULL, _bstr_t(bstrString), _T(&quot;Results&quot;), MB_OK);  

      if(bstrString)  
      {  
         ::SysFreeString(bstrString);  
         bstrString = NULL;  
      }  

   } catch (...) {  
      MessageBox(NULL, _T(&quot;Exception occurred&quot;), _T(&quot;Error&quot;), MB_OK);  
      if(bstrString)  
         ::SysFreeString(bstrString);  
   }  

}</code></pre>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms760305%28v%3dvs.85%29" target="_blank" rel="noopener">IXMLHTTPRequest Members</a>   </p>
<p>前言：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms755648%28v%3dvs.85%29" target="_blank" rel="noopener">Make XML Requests Over HTTP (Smart)</a>        </p>
<h4 id="2-Source-XMLOverHTTP-cpp"><a href="#2-Source-XMLOverHTTP-cpp" class="headerlink" title="2. Source: XMLOverHTTP.cpp"></a>2. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms762674%28v%3dvs.85%29" target="_blank" rel="noopener">Source: XMLOverHTTP.cpp</a></h4><pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#import &lt;msxml6.dll&gt;

// Macro that calls a COM method returning HRESULT value.
#define CHK_HR(stmt)        do { hr=(stmt); if (FAILED(hr)) goto CleanUp; } while(0)

// Macro that releases a COM object if not NULL.
#define SAFE_RELEASE(p)     do { if ((p)) { (p)-&gt;Release(); (p) = NULL; } } while(0)

void XMLOverHTTP()
{
    MSXML2::IXMLHTTPRequestPtr pIXMLHTTPRequest;
    MSXML2::IXMLDOMDocumentPtr pXMLDoc;
    BSTR bstrString = NULL;
    HRESULT hr = S_OK;

    try 
    {
        CHK_HR(pIXMLHTTPRequest.CreateInstance(__uuidof(MSXML2::XMLHTTP60), NULL, CLSCTX_INPROC_SERVER));
        CHK_HR(pIXMLHTTPRequest-&gt;open(&quot;GET&quot;, &quot;http://localhost/sxh/contact.asp?SearchID=John Doe&quot;, _variant_t(VARIANT_FALSE)));
        CHK_HR(pIXMLHTTPRequest-&gt;send());

        pXMLDoc = pIXMLHTTPRequest-&gt;responseXML;
        bstrString = pXMLDoc-&gt;xml;
        if(bstrString)
        {
            printf(&quot;%S\n&quot;, bstrString);
        }
    } 
    catch (_com_error errorObject)
    {
        printf(&quot;Exception thrown, HRESULT: 0x%08x&quot;, errorObject.Error());
    }

CleanUp:
    SysFreeString(bstrString);
}

int _tmain(int argc, _TCHAR* argv[])
{
    HRESULT hr = CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        XMLOverHTTP();
        CoUninitialize();
    }

    return 0;
}</code></pre>
<h3 id="xml解析-1"><a href="#xml解析-1" class="headerlink" title="xml解析"></a>xml解析</h3><h5 id="1-Source-loadDOM-cpp"><a href="#1-Source-loadDOM-cpp" class="headerlink" title="1. Source: loadDOM.cpp"></a>1. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms765465%28v%3dvs.85%29" target="_blank" rel="noopener">Source: loadDOM.cpp</a></h5><pre><code class="cpp">// LoadDOM.cpp : Defines the entry point for the console application.
//

#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#import &lt;msxml6.dll&gt; raw_interfaces_only

// Macro that calls a COM method returning HRESULT value.
#define CHK_HR(stmt)        do { hr=(stmt); if (FAILED(hr)) goto CleanUp; } while(0)

// Macro to verify memory allcation.
#define CHK_ALLOC(p)        do { if (!(p)) { hr = E_OUTOFMEMORY; goto CleanUp; } } while(0)

// Macro that releases a COM object if not NULL.
#define SAFE_RELEASE(p)     do { if ((p)) { (p)-&gt;Release(); (p) = NULL; } } while(0)

// Helper function to create a VT_BSTR variant from a null terminated string. 
HRESULT VariantFromString(PCWSTR wszValue, VARIANT &amp;Variant)
{
    HRESULT hr = S_OK;
    BSTR bstr = SysAllocString(wszValue);
    CHK_ALLOC(bstr);

    V_VT(&amp;Variant)   = VT_BSTR;
    V_BSTR(&amp;Variant) = bstr;

CleanUp:
    return hr;
}

// Helper function to create a DOM instance. 
HRESULT CreateAndInitDOM(IXMLDOMDocument **ppDoc)
{
    HRESULT hr = CoCreateInstance(__uuidof(MSXML2::DOMDocument60), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(ppDoc));
    if (SUCCEEDED(hr))
    {
        // these methods should not fail so don&#39;t inspect result
        (*ppDoc)-&gt;put_async(VARIANT_FALSE);  
        (*ppDoc)-&gt;put_validateOnParse(VARIANT_FALSE);
        (*ppDoc)-&gt;put_resolveExternals(VARIANT_FALSE);
    }
    return hr;
}

void loadDOM()
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pXMLDom=NULL;
    IXMLDOMParseError *pXMLErr = NULL;

    BSTR bstrXML = NULL;
    BSTR bstrErr = NULL;
    VARIANT_BOOL varStatus;
    VARIANT varFileName;
    VariantInit(&amp;varFileName);

    CHK_HR(CreateAndInitDOM(&amp;pXMLDom));    

    // XML file name to load
    CHK_HR(VariantFromString(L&quot;stocks.xml&quot;, varFileName));
    CHK_HR(pXMLDom-&gt;load(varFileName, &amp;varStatus));
    if (varStatus == VARIANT_TRUE)
    {
        CHK_HR(pXMLDom-&gt;get_xml(&amp;bstrXML));
        printf(&quot;XML DOM loaded from stocks.xml:\n%S\n&quot;, bstrXML);
    }
    else
    {
        // Failed to load xml, get last parsing error
        CHK_HR(pXMLDom-&gt;get_parseError(&amp;pXMLErr));
        CHK_HR(pXMLErr-&gt;get_reason(&amp;bstrErr));
        printf(&quot;Failed to load DOM from stocks.xml. %S\n&quot;, bstrErr);
    }

CleanUp:
    SAFE_RELEASE(pXMLDom);
    SAFE_RELEASE(pXMLErr);
    SysFreeString(bstrXML);
    SysFreeString(bstrErr);
    VariantClear(&amp;varFileName);
}

int _tmain(int argc, _TCHAR* argv[])
{
    HRESULT hr = CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        loadDOM();
        CoUninitialize();
    }

    return 0;

}</code></pre>
<h5 id="2-Source-queryNodes-cpp"><a href="#2-Source-queryNodes-cpp" class="headerlink" title="2. Source: queryNodes.cpp"></a>2. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms767609(v=vs.85)" target="_blank" rel="noopener">Source: queryNodes.cpp</a></h5><pre><code class="cpp">// QueryNodes.cpp : Defines the entry point for the console application.
//

#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;msxml6.h&gt;

// Macro that calls a COM method returning HRESULT value.
#define CHK_HR(stmt)        do { hr=(stmt); if (FAILED(hr)) goto CleanUp; } while(0)

// Macro to verify memory allcation.
#define CHK_ALLOC(p)        do { if (!(p)) { hr = E_OUTOFMEMORY; goto CleanUp; } } while(0)

// Macro that releases a COM object if not NULL.
#define SAFE_RELEASE(p)     do { if ((p)) { (p)-&gt;Release(); (p) = NULL; } } while(0)

// Helper function to create a VT_BSTR variant from a null terminated string. 
HRESULT VariantFromString(PCWSTR wszValue, VARIANT &amp;Variant)
{
    HRESULT hr = S_OK;
    BSTR bstr = SysAllocString(wszValue);
    CHK_ALLOC(bstr);

    V_VT(&amp;Variant)   = VT_BSTR;
    V_BSTR(&amp;Variant) = bstr;

CleanUp:
    return hr;
}

// Helper function to create a DOM instance. 
HRESULT CreateAndInitDOM(IXMLDOMDocument **ppDoc)
{
    HRESULT hr = CoCreateInstance(__uuidof(DOMDocument60), NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(ppDoc));
    if (SUCCEEDED(hr))
    {
        // these methods should not fail so don&#39;t inspect result
        (*ppDoc)-&gt;put_async(VARIANT_FALSE);  
        (*ppDoc)-&gt;put_validateOnParse(VARIANT_FALSE);
        (*ppDoc)-&gt;put_resolveExternals(VARIANT_FALSE);
        (*ppDoc)-&gt;put_preserveWhiteSpace(VARIANT_TRUE);
    }
    return hr;
}

// Helper function to display parse error.
// It returns error code of the parse error.
HRESULT ReportParseError(IXMLDOMDocument *pDoc, char *szDesc)
{
    HRESULT hr = S_OK;
    HRESULT hrRet = E_FAIL; // Default error code if failed to get from parse error.
    IXMLDOMParseError *pXMLErr = NULL;
    BSTR bstrReason = NULL;

    CHK_HR(pDoc-&gt;get_parseError(&amp;pXMLErr));
    CHK_HR(pXMLErr-&gt;get_errorCode(&amp;hrRet));
    CHK_HR(pXMLErr-&gt;get_reason(&amp;bstrReason));
    printf(&quot;%s\n%S\n&quot;, szDesc, bstrReason);

CleanUp:
    SAFE_RELEASE(pXMLErr);
    SysFreeString(bstrReason);
    return hrRet;
}

void queryNodes()
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pXMLDom = NULL;
    IXMLDOMNodeList *pNodes = NULL;
    IXMLDOMNode *pNode = NULL;

    BSTR bstrQuery1 = NULL;
    BSTR bstrQuery2 = NULL;
    BSTR bstrNodeName = NULL;
    BSTR bstrNodeValue = NULL;
    VARIANT_BOOL varStatus;
    VARIANT varFileName;
    VariantInit(&amp;varFileName);

    CHK_HR(CreateAndInitDOM(&amp;pXMLDom));

    CHK_HR(VariantFromString(L&quot;stocks.xml&quot;, varFileName));
    CHK_HR(pXMLDom-&gt;load(varFileName, &amp;varStatus));
    if (varStatus != VARIANT_TRUE)
    {
        CHK_HR(ReportParseError(pXMLDom, &quot;Failed to load DOM from stocks.xml.&quot;));
    }

    // Query a single node.
    bstrQuery1 = SysAllocString(L&quot;//stock[1]/*&quot;);
    CHK_ALLOC(bstrQuery1);
    CHK_HR(pXMLDom-&gt;selectSingleNode(bstrQuery1, &amp;pNode));
    if (pNode)
    {
        printf(&quot;Result from selectSingleNode:\n&quot;);
        CHK_HR(pNode-&gt;get_nodeName(&amp;bstrNodeName));
        printf(&quot;Node, &lt;%S&gt;:\n&quot;, bstrNodeName);
        SysFreeString(bstrNodeName);

        CHK_HR(pNode-&gt;get_xml(&amp;bstrNodeValue));
        printf(&quot;\t%S\n\n&quot;, bstrNodeValue);
        SysFreeString(bstrNodeValue);
        SAFE_RELEASE(pNode);
    }
    else
    {
        CHK_HR(ReportParseError(pXMLDom, &quot;Error while calling selectSingleNode.&quot;));
    }

    // Query a node-set.
    bstrQuery2 = SysAllocString(L&quot;//stock[1]/*&quot;);
    CHK_ALLOC(bstrQuery2);
    CHK_HR(pXMLDom-&gt;selectNodes(bstrQuery2, &amp;pNodes));
    if(pNodes)
    {
        printf(&quot;Results from selectNodes:\n&quot;);
        //get the length of node-set
        long length;
        CHK_HR(pNodes-&gt;get_length(&amp;length));
        for (long i = 0; i &lt; length; i++)
        {
            CHK_HR(pNodes-&gt;get_item(i, &amp;pNode));
            CHK_HR(pNode-&gt;get_nodeName(&amp;bstrNodeName));
            printf(&quot;Node (%d), &lt;%S&gt;:\n&quot;, i, bstrNodeName);
            SysFreeString(bstrNodeName);

            CHK_HR(pNode-&gt;get_xml(&amp;bstrNodeValue));
            printf(&quot;\t%S\n&quot;, bstrNodeValue);
            SysFreeString(bstrNodeValue);
            SAFE_RELEASE(pNode);
        }
    }
    else
    {
        CHK_HR(ReportParseError(pXMLDom, &quot;Error while calling selectNodes.&quot;));
    }

CleanUp:
    SAFE_RELEASE(pXMLDom);
    SAFE_RELEASE(pNodes);
    SAFE_RELEASE(pNode);
    SysFreeString(bstrQuery1);
    SysFreeString(bstrQuery2);
    SysFreeString(bstrNodeName);
    SysFreeString(bstrNodeValue);
    VariantClear(&amp;varFileName);
}

int _tmain(int argc, _TCHAR* argv[])
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        queryNodes();
        CoUninitialize();
    }
    return 0;

}</code></pre>
<hr>
<p>前言：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms757060(v=vs.85)" target="_blank" rel="noopener">Program with DOM in C-C++ Using Smart Pointer Class Wrappers</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms763726(v=vs.85)" target="_blank" rel="noopener">Load an XML DOM Object from an XML File (Smart)</a>        </p>
<h5 id="3-Source-loadDOMsmart-cpp"><a href="#3-Source-loadDOMsmart-cpp" class="headerlink" title="3. Source: loadDOMsmart.cpp"></a>3. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms756075%28v%3dvs.85%29" target="_blank" rel="noopener">Source: loadDOMsmart.cpp</a></h5><pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#import &lt;msxml6.dll&gt;

void loadDOMsmart()
{
    MSXML2::IXMLDOMDocumentPtr pXMLDom;
    HRESULT hr= pXMLDom.CreateInstance(__uuidof(MSXML2::DOMDocument60), NULL, CLSCTX_INPROC_SERVER);
    if (FAILED(hr)) 
   {
      printf(&quot;Failed to instantiate an XML DOM.\n&quot;);
      return;
   }

    try
    {
        pXMLDom-&gt;async = VARIANT_FALSE;
        pXMLDom-&gt;validateOnParse = VARIANT_FALSE;
        pXMLDom-&gt;resolveExternals = VARIANT_FALSE;

        if(pXMLDom-&gt;load(&quot;stocks.xml&quot;) == VARIANT_TRUE)
        {
            printf(&quot;XML DOM loaded from stocks.xml:\n%s\n&quot;, (LPCSTR)pXMLDom-&gt;xml);
        }
        else
        {
            // Failed to load xml
            printf(&quot;Failed to load DOM from stocks.xml. %s\n&quot;,
                   (LPCSTR)pXMLDom-&gt;parseError-&gt;Getreason());
        }
    }
    catch(_com_error errorObject)
    {
        printf(&quot;Exception thrown, HRESULT: 0x%08x&quot;, errorObject.Error());
    }
}

int _tmain(int argc, _TCHAR* argv[])
{
    HRESULT hr = CoInitialize(NULL);
    if(SUCCEEDED(hr))
    {
        loadDOMsmart();
        CoUninitialize();
    }

    return 0;

}</code></pre>
<hr>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p><a href="https://blog.csdn.net/e_wsq/article/details/20306705" target="_blank" rel="noopener">BSTR、_bstr_t与CString、char *转换</a><br><a href="https://www.cnblogs.com/hardbrave/articles/3320967.html" target="_blank" rel="noopener">浅谈BSTR、_bstr_t和CComPtr</a><br><code>BSTR</code>被定义为<code>OLECHAR*</code>类型，查看<code>OLECHAR</code>类型的声明，可以发现其实是一个<code>wchar_t</code>类型，也就是说一个<code>BSTR</code>字符串其实是一个<code>Unicode</code>字符串。     </p>
<p>COM中一共提供了两个类来对<code>BSTR</code>进行封装，一个是编译器提供的COM支持类：<code>_bstr_t</code>, 一个ATL库提供的包裹类：<code>CComBSTR</code>.</p>
<p><code>_bstr_t</code>提供的封装层次较低，它仅提供简单的字符串构造、连接以及比较操作，在某种意义上，它更像是一个万能转换头，提供<code>char*、wchar_t*</code>类型到<code>BSTR</code>类型之间的转换。</p>
<p>关于<code>_bstr_t</code>，需要注意的有三点：一是，它内部采用引用计数来管理字符串数组的生命周期；二是，它在构造或操作的过程是有可能抛出异常的；三是，它内部使用<code>SysAllocString</code>和<code>SysFreeString</code>来分配和释放内存，在调用<code>Detach</code>操作之后，<code>_bstr_t</code>内“包裹”的<code>BSTR</code>字符串就会脱离出来，脱离出来的<code>BSTR</code>字符串，是需要手动调用<code>SysFreeString</code>来释放内存的，否则会造成内存泄露问题。</p>
<p><code>CComBSTR</code>提供的封装层次更高，如果要操作<code>BSTR</code>，建议使用<code>CComBSTR</code>。头文件&lt;atlbase.h&gt;<br><a href="https://blog.csdn.net/weikangc/article/details/46008885" target="_blank" rel="noopener">CComBSTR</a></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h5 id="1-CString-→-BSTR"><a href="#1-CString-→-BSTR" class="headerlink" title="1. CString → BSTR"></a>1. CString → BSTR</h5><pre><code class="cpp">bstrText = szStr.AllocSysString();

SysFreeString(bstrText);        //用完释放</code></pre>
<h5 id="2-BSTR-→-CString"><a href="#2-BSTR-→-CString" class="headerlink" title="2. BSTR → CString"></a>2. BSTR → CString</h5><pre><code class="cpp">CString szStr = (LPCSTR)bstrText;

CString szStr(bstrText);</code></pre>
<h5 id="3-bstr-t-→-CString"><a href="#3-bstr-t-→-CString" class="headerlink" title="3. _bstr_t → CString"></a>3. _bstr_t → CString</h5><pre><code class="cpp">CString szStr = (LPCSTR)bstrText;</code></pre>
<h5 id="4-BSTR-→-char"><a href="#4-BSTR-→-char" class="headerlink" title="4. BSTR → char*"></a>4. BSTR → char*</h5><pre><code class="cpp">//方法一
char* lpszStr = _com_util::ConvertBSTRToString(bstrText);
SysFreeString(bstrText);

delete[]lpszStr;

//方法二
_bstr_t b = bstrText;
char* lpszStr = b;</code></pre>
<h5 id="5-char-→-BSTR"><a href="#5-char-→-BSTR" class="headerlink" title="5. char* → BSTR"></a>5. char* → BSTR</h5><pre><code class="cpp">//方法一
bstrText = SysAllocString(lpszStr);
bstrText = SysAllocStringLen(L&quot;Test&quot;,4);
bstrText = SysAllocStringByteLen(L&quot;Test&quot;,4);

//方法二
COleVariant strVar(&quot;This is a test&quot;);
_variant_t strVar(&quot;This is a test&quot;);
bstrText = strVar.bstrVal;

//方法三
bstrText = _bstr_t(&quot;This is a test&quot;);

//方法四
bstrText = CComBSTR(&quot;This is a test&quot;);
CComBSTR bstr(&quot;This is a test&quot;);
bstrText = bstr.m_str;

//方法五
char* lpszStr = &quot;Text&quot;;
bstrText = _com_util::ConvertStringToBSTR(lpszStr);</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2020/04/23/socket/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  socket
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2020/04/23/vue%E7%AC%94%E8%AE%B0/">
                vue笔记
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Been Stone</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>