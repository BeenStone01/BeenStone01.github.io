<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		thread | 
	 
	Been&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="my markdown blog" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Been's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/BeenStone01" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2020/04/23/C++%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B/">
										C++代码样例
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/19/GPIB/">
										GPIB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/Laravel/">
										Laravel
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/Linux%E5%9C%A8%E7%BA%BF/">
										Linux在线
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/29/MFC/">
										MFC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/29/MFC%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
										MFC多线程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/MFC%E8%87%AA%E7%BB%98%E6%8C%89%E9%92%AE/">
										MFC自绘按钮
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/MFC%E8%87%AA%E7%BB%98%E6%A6%82%E8%BF%B0/">
										MFC自绘概述
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/SSDP%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/">
										SSDP开发说明
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/STL_vector/">
										STL_vector
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/STL/">
										STL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/WinHttp%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">
										WinHttp使用详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/WinInet%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">
										WinInet使用详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/Wininte%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90/">
										Wininte样例解析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/26/XML%E4%B9%8BIXMLHTTPReuest/">
										XML之IXMLHTTPReuest
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/XML%E6%93%8D%E4%BD%9C%E4%B9%8BCMarkUp/">
										XML操作之CMarkUp
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/XML%E8%A7%A3%E6%9E%90/">
										XML解析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/c++11/">
										c++11
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/06/c++%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										c++小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/26/c-%E6%9C%AA%E5%BD%92%E7%B1%BB%E4%BB%A3%E7%A0%81/">
										c-未归类代码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/hexo/">
										hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/socket/">
										socket
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/thread-2/">
										thread-2
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2020/04/23/thread/">
										thread
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/vue%E7%AC%94%E8%AE%B0/">
										vue笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/webpack%E4%BD%BF%E7%94%A8/">
										webpack使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/30/%E4%B8%B2%E5%8F%A3com%E7%BC%96%E7%A8%8B/">
										串口com编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/03/%E5%88%B7%E9%A2%98%E7%BA%AA%E5%BD%95/">
										刷题纪录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/">
										字符类型
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">
										小程序开发笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/24/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">
										常用工具命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/">
										文件读写
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/04/23/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/">
										编码格式转换
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	thread
</h1>
<div class="article-meta">
	
	<span>Been Stone</span>
	<span>2020-04-23 17:08:18</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><p>同步vs异步<br>异步：<br>同步：一个一个执行</p>
<p>adopt_lock, try_to_lock, defer_lock详见unique_lock<br><a href="https://blog.csdn.net/u012372584/article/details/96867805" target="_blank" rel="noopener">call_once()函数详解</a><br>只使用一次</p>
<h2 id="并发-VS-并行"><a href="#并发-VS-并行" class="headerlink" title="并发 VS 并行"></a>并发 VS 并行</h2><p>说到多线程编程，那么就不得不提并行和并发，多线程是实现并发（并行）的一种手段。并行是指两个或多个独立的操作同时进行。注意这里是同时进行，区别于并发，在一个时间段内执行多个操作。在单核时代，多个线程是并发的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的并行，在多核上真正独立的并行执行。例如现在常见的4核4线程可以并行4个线程；4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。</p>
<h2 id="并发编程的方法"><a href="#并发编程的方法" class="headerlink" title="并发编程的方法"></a>并发编程的方法</h2><p>通常，要实现并发有两种方法：多进程和多线程。</p>
<h3 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h3><p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。</p>
<ul>
<li>由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。<br>但这也造就了多进程并发的两个缺点：</li>
<li>在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。</li>
<li>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。</li>
</ul>
<p>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。</p>
<h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h3><p>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p>
<p>C++11 新标准中引入了几个头文件来支持多线程编程：</p>
<blockquote>
<p>&lt; thread &gt;：包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在 中声明.<br>&lt; atomic &gt;：包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。<br>&lt; mutex &gt;：包含了与互斥量相关的类以及其他类型和函数<br>&lt; future &gt;：包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。<br>&lt; condition_variable &gt;：包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。</p>
</blockquote>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>创建一个对象，即启动一个线程<br>向线程函数传递参数，需要注意的是线程默认是以拷贝的方式传递参数的，当期望传入一个引用时，要使用ref()进行转换。<br>movable<br>joinable</p>
<p>this_thread::get_id(); 每个线程都有一个标识，可以调用此函数获取<br>this_thread::sleep_for();<br>this_thread::sleep_until();</p>
<h2 id="一-子线程调用"><a href="#一-子线程调用" class="headerlink" title="一. 子线程调用"></a>一. 子线程调用</h2><h3 id="1-类外部创建"><a href="#1-类外部创建" class="headerlink" title="1. 类外部创建"></a>1. 类外部创建</h3><pre><code class="cpp">class A
{
public:
    void f(int a,char c) {};
    int operator()(int N) { return 0; };
};

void fun1() {}
void fun2(int a,int b) { cout &lt;&lt; a+b; }

int main()
{
    thread t0(fun1)            //1. 无参型
    thread t5(fun2, 6);        //2. 有参型
    thread t6([](int x) {return x * x; }, 6);

    A a;
    thread t1(a, 6);        //传递a的拷贝给子线程
    thread t2(ref(a), 6);    //传递a的引用给子线程
    thread t3(move(a), 6);    //a在主线程中将不再有效
    thread t4(A(), 6);        //传递临时创建的a对象给子线程
    thread t7(&amp;A::f, a, 8, &#39;w&#39;);    //传递a拷贝的成员函数给子线程
    thread t8(&amp;A::f, &amp;a, 8, &#39;w&#39;);    //传递a地址的成员函数给子线程

    async(launch::async, a, 6);

    system(&quot;pause&quot;);                
    return 0;
}</code></pre>
<h3 id="2-类内部创建"><a href="#2-类内部创建" class="headerlink" title="2. 类内部创建"></a>2. 类内部创建</h3><pre><code class="cpp">class Person
{
public:
    static void hello(int year)
    {
        cout &lt;&lt; &quot;I am &quot; &lt;&lt; year &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;
    }
    static void start()            //两个函数必须是static
    {
        thread th(hello, 12);
        th.join();
    }
};

void test()
{
    Person::start();
}</code></pre>
<h3 id="3-join-vs-detach"><a href="#3-join-vs-detach" class="headerlink" title="3. join() vs detach()"></a>3. join() vs detach()</h3><pre><code class="cpp">mutex mt;
int data1 = 1;

void add(int a)
{
    mt.lock();
    data1 += a;
    cout &lt;&lt; &quot;add data1 &quot; &lt;&lt; data1 &lt;&lt; endl;
    mt.unlock();
}

void multi(int a)
{
    mt.lock();
    data1 *= a;
    cout &lt;&lt; &quot;multi data1 &quot; &lt;&lt; data1 &lt;&lt; endl;
    mt.unlock();
}
//join(): 主线程等待子线程结束后方可执行下一步（串行），detach()是子线程独立于主线程并发执行，主线程后续代码无需等待。 detach以后就失去了对线程的所有权，不能再调用join了，因为线程已经分离出去了，不再归该实例管了。判断线程是否还有对线程的所有权的一个简单方式是调用joinable函数，返回true则有，否则为无。
void main4()
{
    thread t1(add, 2);
    thread t2(multi, 10);
    t1.detach();
    t2.detach();
    cout &lt;&lt; &quot;Main here&quot; &lt;&lt; endl;
}</code></pre>
<p>执行结果</p>
<pre><code class="shell">add data1 3
Main here
multi data1 30
请按任意键继续. . .</code></pre>
<p>如果换作join()</p>
<pre><code class="shell">add data1 3
multi data1 30
Main here
请按任意键继续. . .</code></pre>
<h3 id="4-线程暂停"><a href="#4-线程暂停" class="headerlink" title="4. 线程暂停"></a>4. 线程暂停</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;

using namespace std;

void pausable()
{
    this_thread::sleep_for(chrono::milliseconds(500));
    cout &lt;&lt; &quot;好了吗？&quot; &lt;&lt; endl;
    this_thread::sleep_until(chrono::system_clock::now() + chrono::milliseconds(500));
    cout &lt;&lt; &quot;haimeihao&quot; &lt;&lt; endl;
}

int main()
{
    std::thread th(pausable);
    th.join();

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h3 id="5-线程拷贝"><a href="#5-线程拷贝" class="headerlink" title="5. 线程拷贝"></a>5. 线程拷贝</h3><pre><code class="cpp">thread a(foo);
thread b;
b = a;</code></pre>
<p>赋完值后，原来由a管理的线程改为由b管理，b不再指向任何线程(相当于执行了detach操作)。如果b原本指向了一个线程，那么这个线程会被终止掉。</p>
<h2 id="二-线程同步的方法："><a href="#二-线程同步的方法：" class="headerlink" title="二. 线程同步的方法："></a>二. 线程同步的方法：</h2><h3 id="1-互斥对象；"><a href="#1-互斥对象；" class="headerlink" title="1. 互斥对象；"></a>1. 互斥对象；</h3><pre><code class="cpp">#include &lt;iostream&gt;   
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;numeric&gt;

using namespace std;

int total = 100;

void fun1(mutex&amp; mt)
{
    while (1)
    {
        mt.lock();
        if (total &gt; 0)
        {
            cout &lt;&lt; &quot;窗口1卖票一张，尚余&quot; &lt;&lt; --total &lt;&lt; &quot;张&quot; &lt;&lt; endl;
            mt.unlock();
        }
        else
        {
            mt.unlock();
            break;
        }
        this_thread::sleep_for(chrono::milliseconds(50));
    }
}

void fun2(mutex&amp; mt)
{
    while (1)
    {
        mt.lock();
        if (total&gt;0)
        {
            cout &lt;&lt; &quot;窗口2卖票一张, 尚余&quot; &lt;&lt; --total &lt;&lt; &quot;张&quot; &lt;&lt; endl;
            mt.unlock();
        }
        else
        {
            mt.unlock();
            break;
        }
        this_thread::sleep_for(chrono::milliseconds(50));
    }
}

int main()
{
    mutex mt;

    thread th1(fun1,ref(mt));
    thread th2(fun2,ref(mt));
    th1.join();
    th2.join();

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h4 id="另类写法"><a href="#另类写法" class="headerlink" title="另类写法"></a><a href="https://blog.csdn.net/u011808673/article/details/80811998" target="_blank" rel="noopener">另类写法</a></h4><p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html" target="_blank" rel="noopener">c++11之lambda函数</a><br>thread th2(<code>[&amp;]</code>(){<br>    //处理过程<br>    });</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

using namespace std;

int increase(int* p, int times, mutex&amp; mtx)
{
    for (int i = 0; i &lt; times; i++)
    {
        mtx.lock();
        ++* p;
        mtx.unlock();
    }
    return 0;
}

int main()
{
    int num = 0;
    mutex mtx;

    thread th1([&amp;]() {
        increase(&amp;num, 10000, mtx);
    });

    thread th2([&amp;]() {
        for (int i = 0; i &lt; 10000; i++)
        {
            mtx.lock();
            ++num;
            mtx.unlock();
        }
    });
    th1.join();
    th2.join();


    cout &lt;&lt; &quot;num=&quot; &lt;&lt; num &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h3 id="2-lock-guard-VS-unique-lock"><a href="#2-lock-guard-VS-unique-lock" class="headerlink" title="2. lock_guard VS unique_lock"></a>2. <a href="https://blog.csdn.net/u011808673/article/details/80811998" target="_blank" rel="noopener">lock_guard VS unique_lock</a></h3><p>C++多线程编程中通常会对共享的数据进行写保护，以防止多线程在对共享数据成员进行读写时造成资源争抢导致程序出现未定义的行为。</p>
<p>通常的做法是在修改共享数据成员的时候进行加锁–mutex。在使用锁的时候通常是在对共享数据进行修改之前进行lock操作，在写完之后再进行unlock操作，进场会出现由于疏忽导致由于lock之后在离开共享成员操作区域时忘记unlock，导致死锁。</p>
<p>针对以上的问题，C++11中引入了<code>std::lock_guard</code>与<code>std::unique_lock</code>两种数据结构。通过对lock和unlock进行一次薄的封装，实现自动unlock的功能。<br>==区别：==<br>std::unique_lock 与std::lock_guard都能实现自动加锁与解锁功能，但是std::unique_lock要比std::lock_guard更灵活(可以精细化加解锁)，但是更灵活的代价是占用空间相对更大一点且相对更慢一点。</p>
<h4 id="1-lock-guard"><a href="#1-lock-guard" class="headerlink" title="1). lock_guard"></a>1). lock_guard</h4><p>有作用域的mutex,让程序更稳定，防止死锁</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;condition_variable&gt;
std::condition_variable cv;
std::mutex mutx;
int ticket = 100;
bool isrunning = true;
void consumer(int id)
{
    while (ticket &gt; 0)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        std::lock_guard&lt;std::mutex&gt; lck(mutx);
        if (ticket &gt; 0)
        {
            int x = (rand() % (10 - 1)) + 1;
            if (x &gt; ticket)
                x = ticket;
            std::cout &lt;&lt; &quot;售票窗口[&quot; &lt;&lt; id &lt;&lt; &quot;]: &quot;;
            ticket -= x;
            std::cout &lt;&lt; &quot;售出 &quot; &lt;&lt; x &lt;&lt; &quot;票&quot; &lt;&lt; std::endl;
            std::cout &lt;&lt; &quot;剩余 &quot; &lt;&lt; ticket &lt;&lt; &quot;票&quot; &lt;&lt; std::endl;
        }
        else
        {
            std::cout &lt;&lt; &quot;售票窗口[&quot; &lt;&lt; id &lt;&lt; &quot;]: &quot;;
            std::cout &lt;&lt; &quot;票已经售完...&quot; &lt;&lt; std::endl;
        }
    }
}
int main()
{
    std::cout &lt;&lt; &quot;main thread:&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;总共票数为&quot; &lt;&lt; ticket &lt;&lt; std::endl;
    std::thread c[5];
    for (int i = 0; i &lt; 5; i++)
        c[i] = std::thread(consumer, i + 1);
    for (int i = 0; i &lt; 5; i++)
        c[i].join();
    std::cout &lt;&lt; &quot;it&#39;s over...&quot; &lt;&lt; std::endl;

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h4 id="2-unique-lock"><a href="#2-unique-lock" class="headerlink" title="2). unique_lock"></a>2). <a href="https://blog.csdn.net/u012507022/article/details/85909567" target="_blank" rel="noopener">unique_lock</a></h4><pre><code class="cpp">//交替输出
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;Windows.h&gt;

using namespace std;

std::mutex mtx_syn;
std::condition_variable cv_syn;
std::condition_variable cv_syn_1;
bool ready = false;

void threadA(int id) {
    while (1)
    {
        std::unique_lock&lt;std::mutex&gt; lck(mtx_syn);
        while (!ready) cv_syn.wait(lck);
        // ...
        std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#39;\n&#39;;
        Sleep(500);
        cv_syn.notify_all();   //cpu 轮询执行 所有被唤醒的线程。
        cv_syn.wait(lck);
    }

}

void threadB(int id) {
    while (1)
    {
        //新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将会被阻塞
        std::unique_lock&lt;std::mutex&gt; lck(mtx_syn);
        while (!ready) cv_syn.wait(lck);
        // ...
        std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#39;\n&#39;;
        Sleep(500);
        cv_syn.notify_all();
        cv_syn.wait(lck);
    }
}

void threadC(int id) {
    while (1)
    {
        std::unique_lock&lt;std::mutex&gt; lck(mtx_syn);
        while (!ready) cv_syn_1.wait(lck);
        // ...
        std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#39;\n&#39;;
        Sleep(500);
        cv_syn_1.notify_all();
        cv_syn_1.wait(lck);
    }
}

void go()
{
    std::unique_lock&lt;std::mutex&gt; lck(mtx_syn);
    ready = true;
    cv_syn.notify_one();
}

int main()
{
    //线程同步
    thread threads[5];
    // spawn 10 threads:
    //for (int i = 0; i&lt;5; ++i)
    //    threads[i] = std::thread(print_id, i);

    threads[0] = std::thread(threadA, 0);
    threads[1] = std::thread(threadB, 1);
    threads[2] = std::thread(threadC, 2);  //该线程 与 0， 1 无关，不影响 0，1 线程的同步，因为用的不是一个 condition_variable
    std::cout &lt;&lt; &quot;2 threads ready to race...\n&quot;;
    go();                       // go!

    for (auto&amp; th : threads) th.join();

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p>示例2：defer_lock的使用：默认不上锁</p>
<pre><code class="cpp">void shared_print(string msg, int id) {
    std::unique_lock&lt;std::mutex&gt; guard(_mu, std::defer_lock);
    //do something 1

    guard.lock();
    // do something protected
    guard.unlock(); //临时解锁

    //do something 2

    guard.lock(); //继续上锁
    // do something 3
    f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;
    cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;
    // 结束时析构guard会临时解锁
}</code></pre>
<h3 id="3-原子变量"><a href="#3-原子变量" class="headerlink" title="3. 原子变量"></a>3. 原子变量</h3><pre><code class="cpp">#include&lt;iostream&gt;  
#include&lt;thread&gt;  
#include&lt;atomic&gt;  
using namespace std;  
const int N = 100000000;  
atomic_int num{ 0 };//不会发生线程冲突，线程安全  
void run()  
{  
    for (int i = 0; i &lt; N; i++)  
    {  
        num++;  
    }  
}  
int main()  
{  
    clock_t start = clock();  
    thread t1(run);  
    thread t2(run);  
    t1.join();  
    t2.join();  
    clock_t end = clock();  
    cout &lt;&lt; &quot;num=&quot; &lt;&lt; num &lt;&lt; &quot;,用时 &quot; &lt;&lt; end - start &lt;&lt; &quot; ms&quot; &lt;&lt; endl;  
    return 0;  
}</code></pre>
<h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><h3 id="1-线程功能拓展"><a href="#1-线程功能拓展" class="headerlink" title="1. 线程功能拓展"></a>1. <a href="https://www.cnblogs.com/shuqingstudy/p/9747004.html" target="_blank" rel="noopener">线程功能拓展</a></h3><pre><code class="cpp">#include&lt;iostream&gt;  
#include&lt;thread&gt;  
using namespace std;
class MyThread :public thread   //继承thread  
{
public:
    //子类MyThread()继承thread()的构造函数  
    MyThread() : thread()
    {
    }
    //MyThread()初始化构造函数  
    template&lt;typename T, typename...Args&gt;
    MyThread(T&amp;&amp;func, Args&amp;&amp;...args) : thread(forward&lt;T&gt;(func), forward&lt;Args&gt;(args)...)
    {
    }
    void showcmd(const char *str)  //运行system  
    {
        system(str);
    }
};
int main()
{
    MyThread th1([]()
    {
        cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
    });
    th1.showcmd(&quot;calc&quot;); //运行calc  
    //lambda  
    MyThread th2([](const char * str)
    {
        cout &lt;&lt; &quot;hello&quot; &lt;&lt; str &lt;&lt; endl;
    }, &quot; this is MyThread&quot;);
    th2.showcmd(&quot;notepad&quot;);//运行notepad  

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p>数据竞争与互斥对象</p>
<pre><code class="cpp">#include &lt;iostream&gt;   
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;

using namespace std;

class LogFile
{
public:
    LogFile() {
        f.open(&quot;log.txt&quot;);
    }
    void share_print(string id, int value)
    {
        lock_guard&lt;mutex&gt; locker(m_mutex);
        f &lt;&lt; &quot;From&quot; &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; value &lt;&lt; endl;
    }

private:
    mutex m_mutex;
    ofstream f;
};

void function_1(LogFile&amp; log)
{
    for (int i = 0; i&gt; -100; i--)
    {
        log.share_print(&quot;From t1:&quot;, i);
    }
}

int main()
{
    LogFile log;
    thread t1(function_1,ref(log));
    for (int i = 0; i &lt; 100; i++)
    {
        log.share_print(&quot;From main:&quot;, i);
    }
    t1.join();

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p>数据竞争与互斥对象(2)</p>
<pre><code class="cpp">#include &lt;iostream&gt;   
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;fstream&gt;

using namespace std;

class LogFile
{
public:
    LogFile() {

    }
    void share_print1(string id, int value)
    {
        lock(m_mutex1, m_mutex2);
        lock_guard&lt;mutex&gt; locker1(m_mutex1,adopt_lock);
        lock_guard&lt;mutex&gt; locker2(m_mutex2,adopt_lock);
        cout &lt;&lt; &quot;From&quot; &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; value &lt;&lt; endl;
    }

    void share_print2(string id, int value)
    {
        lock(m_mutex1, m_mutex2);
        lock_guard&lt;mutex&gt; locker2(m_mutex2, adopt_lock);
        lock_guard&lt;mutex&gt; locker1(m_mutex1, adopt_lock);
        cout &lt;&lt; &quot;From&quot; &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; value &lt;&lt; endl;
    }

private:
    mutex m_mutex1,m_mutex2;
};

void function_1(LogFile&amp; log)
{
    for (int i = 0; i &gt; -100; i--)
    {
        log.share_print1(&quot;From t1:&quot;, i);
    }
}

int main()
{
    LogFile log;
    thread t1(function_1, ref(log));
    for (int i = 0; i &lt; 100; i++)
    {
        log.share_print2(&quot;From main:&quot;, i);
    }
    t1.join();

    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h2 id="题库样例"><a href="#题库样例" class="headerlink" title="题库样例"></a>题库样例</h2><h3 id="1-交替打印"><a href="#1-交替打印" class="headerlink" title="1. 交替打印"></a>1. 交替打印</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
//#include &lt;mutex&gt;
//#include &lt;Windows.h&gt;

using namespace std;

class FooBar {
private:
    int n;
    volatile int mu = 1;
public:

    FooBar(int n) {
        this-&gt;n = n;
    }

    void foo(function&lt;void()&gt; printFoo) {

        for (int i = 0; i &lt; n; i++) {
            // printFoo() outputs &quot;foo&quot;. Do not change or remove this line.
            while (mu != 1) {}
            printFoo();
            mu++;
        }
    }

    void bar(function&lt;void()&gt; printBar) {

        for (int i = 0; i &lt; n; i++) {
            // printBar() outputs &quot;bar&quot;. Do not change or remove this line.
            while (mu != 2) {}
            printBar();
            mu = 1;
        }
    }

};

int main()
{
    FooBar f(100);
    thread th1(&amp;FooBar::foo, &amp;f, []() {cout &lt;&lt; &quot;foo&quot;; });
    thread th2(&amp;FooBar::bar, &amp;f, []() {cout &lt;&lt; &quot;bar&quot; &lt;&lt; endl; });

    th1.join();
    th2.join();
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<p>解法2: 信号量</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;Windows.h&gt;

using namespace std;

class FooBar {
private:
    int n;
    HANDLE hS = CreateSemaphore(NULL, 1, 2, L&quot;ces&quot;);
public:
    FooBar(int n) {
        this-&gt;n = n;
    }

    void foo(function&lt;void()&gt; printFoo) {

        for (int i = 0; i &lt; n; i++) {
            // printFoo() outputs &quot;foo&quot;. Do not change or remove this line.
            WaitForSingleObject(hS, INFINITE);    //大于0，减1后返回
            printFoo();
            Sleep(1);
            ReleaseSemaphore(hS, 1, NULL);    //加1
        }
    }

    void bar(function&lt;void()&gt; printBar) {

        for (int i = 0; i &lt; n; i++) {
            // printBar() outputs &quot;bar&quot;. Do not change or remove this line.
            WaitForSingleObject(hS, INFINITE);
            printBar();
            Sleep(1);
            ReleaseSemaphore(hS, 1, NULL);
        }
    }

};

int main()
{
    FooBar f(200);
    thread th1(&amp;FooBar::foo, &amp;f, []() {cout &lt;&lt; &quot;foo&quot;; });
    thread th2(&amp;FooBar::bar, &amp;f, []() {cout &lt;&lt; &quot;bar&quot; &lt;&lt; endl; });

    th1.join();
    th2.join();
    system(&quot;pause&quot;);
    return 0;
}</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2020/04/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  小程序开发笔记
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2020/04/23/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/">
                文件读写
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Been Stone</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>